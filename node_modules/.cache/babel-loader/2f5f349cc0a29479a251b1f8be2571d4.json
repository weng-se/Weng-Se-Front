{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport scroll from 'scroll';\nimport nested from 'nested-property';\nimport { getRootEl, getOffsetBoundingClientRect, logger, sanitizeSelector, getDocHeight } from './utils';\nimport Beacon from './Beacon';\nimport Tooltip from './Tooltip';\nvar defaultState = {\n  action: '',\n  index: 0,\n  isRunning: false,\n  isTourSkipped: false,\n  shouldRedraw: true,\n  shouldRenderTooltip: false,\n  shouldRun: false,\n  standaloneData: false,\n  // The standalone tooltip data\n  xPos: -1000,\n  yPos: -1000\n};\nvar callbackTypes = {\n  STEP_BEFORE: 'step:before',\n  BEACON_BEFORE: 'beacon:before',\n  BEACON_TRIGGER: 'beacon:trigger',\n  TOOLTIP_BEFORE: 'tooltip:before',\n  STEP_AFTER: 'step:after',\n  STANDALONE_BEFORE: 'standalone:before',\n  STANDALONE_AFTER: 'standalone:after',\n  OVERLAY: 'overlay:click',\n  HOLE: 'hole:click',\n  FINISHED: 'finished',\n  TARGET_NOT_FOUND: 'error:target_not_found'\n};\nvar DEFAULTS = {\n  position: 'top',\n  minWidth: 290\n};\nvar hasTouch = false;\n\nvar Joyride = function (_React$Component) {\n  _inherits(Joyride, _React$Component);\n\n  function Joyride(props) {\n    _classCallCheck(this, Joyride);\n\n    var _this = _possibleConstructorReturn(this, (Joyride.__proto__ || Object.getPrototypeOf(Joyride)).call(this, props));\n\n    _this.handleKeyboardNavigation = function (e) {\n      var _this$state = _this.state,\n          index = _this$state.index,\n          shouldRenderTooltip = _this$state.shouldRenderTooltip;\n      var steps = _this.props.steps;\n      var intKey = window.Event ? e.which : e.keyCode;\n      var hasSteps = void 0;\n\n      if (shouldRenderTooltip) {\n        if ([32, 38, 40].indexOf(intKey) !== -1) {\n          e.preventDefault();\n        }\n\n        if (intKey === 27) {\n          _this.toggleTooltip({\n            show: false,\n            index: index + 1,\n            action: 'esc'\n          });\n        } else if ([13, 32].indexOf(intKey) !== -1) {\n          hasSteps = Boolean(steps[index + 1]);\n\n          _this.toggleTooltip({\n            show: hasSteps,\n            index: index + 1,\n            action: 'next'\n          });\n        }\n      }\n    };\n\n    _this.handleClickStandaloneTrigger = function (e) {\n      e.preventDefault();\n      var _this$state2 = _this.state,\n          isRunning = _this$state2.isRunning,\n          standaloneData = _this$state2.standaloneData;\n      var tooltipData = e.currentTarget.dataset.tooltip;\n\n      if (['mouseenter', 'mouseleave'].indexOf(e.type) !== -1 && hasTouch) {\n        return;\n      }\n      /* istanbul ignore else */\n\n\n      if (tooltipData) {\n        tooltipData = JSON.parse(tooltipData);\n\n        if (!standaloneData || standaloneData.selector !== tooltipData.selector) {\n          _this.setState({\n            isRunning: false,\n            shouldRenderTooltip: false,\n            shouldRun: isRunning,\n            standaloneData: tooltipData,\n            xPos: -1000,\n            yPos: -1000\n          });\n        } else {\n          document.querySelector('.joyride-tooltip__close').click();\n        }\n      }\n    };\n\n    _this.handleClickBeacon = function (e) {\n      e.preventDefault();\n      var index = _this.state.index;\n      var steps = _this.props.steps;\n\n      _this.triggerCallback({\n        action: e.type,\n        index: index,\n        type: callbackTypes.BEACON_TRIGGER,\n        step: steps[index]\n      });\n\n      _this.toggleTooltip({\n        show: true,\n        index: index,\n        action: 'beacon:' + e.type\n      });\n    };\n\n    _this.handleClickTooltip = function (e) {\n      var _this$state3 = _this.state,\n          index = _this$state3.index,\n          shouldRun = _this$state3.shouldRun;\n      var _this$props = _this.props,\n          steps = _this$props.steps,\n          type = _this$props.type;\n      var el = e.currentTarget.className.indexOf('joyride-') !== -1 && ['A', 'BUTTON'].indexOf(e.currentTarget.tagName) !== -1 ? e.currentTarget : e.target;\n      var dataType = el.dataset.type;\n      /* istanbul ignore else */\n\n      if (typeof el.className === 'string' && el.className.startsWith('joyride-')) {\n        e.preventDefault();\n        e.stopPropagation();\n        var tooltip = document.querySelector('.joyride-tooltip');\n        var newIndex = index + (dataType === 'back' ? -1 : 1);\n\n        if (dataType === 'skip') {\n          _this.setState({\n            isTourSkipped: true\n          });\n\n          newIndex = steps.length + 1;\n        }\n        /* istanbul ignore else */\n\n\n        if (tooltip.classList.contains('joyride-tooltip--standalone')) {\n          _this.setState({\n            isRunning: shouldRun,\n            shouldRedraw: true,\n            shouldRun: false,\n            standaloneData: false\n          });\n        } else if (dataType) {\n          var shouldDisplay = ['continuous', 'guided'].indexOf(type) !== -1 && !(['close', 'skip'].indexOf(dataType) !== -1) && Boolean(steps[newIndex]);\n\n          _this.toggleTooltip({\n            show: shouldDisplay,\n            index: newIndex,\n            action: dataType\n          });\n        }\n\n        if (e.target.className === 'joyride-overlay') {\n          _this.triggerCallback({\n            action: 'click',\n            type: callbackTypes.OVERLAY,\n            step: steps[index]\n          });\n        }\n\n        if (e.target.classList.contains('joyride-hole')) {\n          _this.triggerCallback({\n            action: 'click',\n            type: callbackTypes.HOLE,\n            step: steps[index]\n          });\n        }\n      }\n    };\n\n    _this.handleRenderTooltip = function () {\n      _this.calcPlacement();\n    };\n\n    _this.state = _extends({}, defaultState);\n    _this.listeners = {\n      tooltips: {}\n    };\n    return _this;\n  }\n\n  _createClass(Joyride, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var _props = this.props,\n          autoStart = _props.autoStart,\n          keyboardNavigation = _props.keyboardNavigation,\n          resizeDebounce = _props.resizeDebounce,\n          resizeDebounceDelay = _props.resizeDebounceDelay,\n          run = _props.run,\n          steps = _props.steps,\n          type = _props.type;\n      logger({\n        type: 'joyride:initialized',\n        msg: [this.props],\n        debug: this.props.debug\n      });\n      var stepsAreValid = this.checkStepsValidity(steps);\n\n      if (steps && stepsAreValid && run) {\n        this.start(autoStart);\n      }\n\n      if (resizeDebounce) {\n        var timeoutId = void 0;\n\n        this.listeners.resize = function () {\n          clearTimeout(timeoutId);\n          timeoutId = setTimeout(function () {\n            timeoutId = null;\n\n            _this2.calcPlacement();\n          }, resizeDebounceDelay);\n        };\n      } else {\n        this.listeners.resize = function () {\n          _this2.calcPlacement();\n        };\n      }\n\n      window.addEventListener('resize', this.listeners.resize);\n      /* istanbul ignore else */\n\n      if (keyboardNavigation && type === 'continuous') {\n        this.listeners.keyboard = this.handleKeyboardNavigation;\n        document.body.addEventListener('keydown', this.listeners.keyboard);\n      }\n\n      window.addEventListener('touchstart', function setHasTouch() {\n        hasTouch = true; // Remove event listener once fired, otherwise it'll kill scrolling\n        // performance\n\n        window.removeEventListener('touchstart', setHasTouch);\n      }, false);\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      logger({\n        type: 'joyride:willReceiveProps',\n        msg: [nextProps],\n        debug: nextProps.debug\n      });\n      var _state = this.state,\n          isRunning = _state.isRunning,\n          shouldRun = _state.shouldRun,\n          standaloneData = _state.standaloneData;\n      var _props2 = this.props,\n          keyboardNavigation = _props2.keyboardNavigation,\n          run = _props2.run,\n          steps = _props2.steps,\n          stepIndex = _props2.stepIndex;\n      var stepsChanged = nextProps.steps !== steps;\n      var stepIndexChanged = nextProps.stepIndex !== stepIndex && nextProps.stepIndex !== this.state.index;\n      var runChanged = nextProps.run !== run;\n      var shouldStart = false;\n      var didStop = false;\n\n      if (stepsChanged && this.checkStepsValidity(nextProps.steps)) {\n        // Removed all steps, so reset\n        if (!nextProps.steps || !nextProps.steps.length) {\n          this.reset();\n        } // Start the joyride if steps were added for the first time, and run prop is true\n        else if (!steps.length && nextProps.run) {\n            shouldStart = true;\n          }\n      }\n      /* istanbul ignore else */\n\n\n      if (runChanged) {\n        // run prop was changed to off, so stop the joyride\n        if (run && !nextProps.run) {\n          this.stop();\n          didStop = true;\n        } // run prop was changed to on, so start the joyride\n        else if (!run && nextProps.run) {\n            shouldStart = true;\n          } // Was not playing, but should, and isn't a standaloneData\n          else if (!isRunning && shouldRun && !standaloneData) {\n              shouldStart = true;\n            }\n      }\n      /* istanbul ignore else */\n\n\n      if (stepIndexChanged) {\n        var hasStep = nextProps.steps[nextProps.stepIndex];\n        var shouldDisplay = hasStep && nextProps.autoStart;\n\n        if (runChanged && shouldStart) {\n          this.start(nextProps.autoStart, nextProps.steps, nextProps.stepIndex);\n        } // Next prop is set to run, and the index has changed, but for some reason joyride is not running\n        // (maybe this is because of a target not mounted, and the app wants to skip to another step)\n        else if (nextProps.run && !isRunning) {\n            this.start(nextProps.autoStart, nextProps.steps, nextProps.stepIndex);\n          } else if (!didStop) {\n            this.toggleTooltip({\n              show: shouldDisplay,\n              index: nextProps.stepIndex,\n              steps: nextProps.steps,\n              action: 'jump'\n            });\n          }\n      } // Did not change the index, but need to start up the joyride\n      else if (shouldStart) {\n          this.start(nextProps.autoStart, nextProps.steps);\n        } // Update keyboard listeners if necessary\n\n      /* istanbul ignore else */\n\n\n      if (!this.listeners.keyboard && (!keyboardNavigation && nextProps.keyboardNavigation || keyboardNavigation) && nextProps.type === 'continuous') {\n        this.listeners.keyboard = this.handleKeyboardNavigation;\n        document.body.addEventListener('keydown', this.listeners.keyboard);\n      } else if (this.listeners.keyboard && keyboardNavigation && (!nextProps.keyboardNavigation || nextProps.type !== 'continuous')) {\n        document.body.removeEventListener('keydown', this.listeners.keyboard);\n        delete this.listeners.keyboard;\n      }\n    }\n  }, {\n    key: 'componentWillUpdate',\n    value: function componentWillUpdate(nextProps, nextState) {\n      var _state2 = this.state,\n          index = _state2.index,\n          isRunning = _state2.isRunning,\n          shouldRenderTooltip = _state2.shouldRenderTooltip,\n          standaloneData = _state2.standaloneData;\n      var steps = this.props.steps;\n      var nextSteps = nextProps.steps;\n      var step = steps[index];\n      var nextStep = nextSteps[nextState.index];\n      var hasRenderedTarget = Boolean(this.getStepTargetElement(nextStep)); // Standalone tooltip is being turned on\n\n      if (!standaloneData && nextState.standaloneData) {\n        this.triggerCallback({\n          type: callbackTypes.STANDALONE_BEFORE,\n          step: nextState.standaloneData\n        });\n      } // Standalone tooltip is being turned off\n      else if (standaloneData && !nextState.standaloneData) {\n          this.triggerCallback({\n            type: callbackTypes.STANDALONE_AFTER,\n            step: standaloneData\n          });\n        } // Tried to start, but something went wrong and we're not actually running\n\n\n      if (nextState.action === 'start' && !nextState.isRunning) {\n        // There's a step to use, but there's no target in the DOM\n        if (nextStep && !hasRenderedTarget) {\n          console.warn('Target not mounted', nextStep, nextState.action); //eslint-disable-line no-console\n\n          this.triggerCallback({\n            action: 'start',\n            index: nextState.index,\n            type: callbackTypes.TARGET_NOT_FOUND,\n            step: nextStep\n          });\n        }\n      } // Started running from the beginning (the current index is 0)\n\n\n      if (!isRunning && nextState.isRunning && nextState.index === 0) {\n        this.triggerCallback({\n          action: 'start',\n          index: nextState.index,\n          type: callbackTypes.STEP_BEFORE,\n          step: nextStep\n        }); // Not showing a tooltip yet, so we're going to show a beacon instead\n\n        /* istanbul ignore else */\n\n        if (!nextState.shouldRenderTooltip) {\n          this.triggerCallback({\n            action: 'start',\n            index: nextState.index,\n            type: callbackTypes.BEACON_BEFORE,\n            step: nextStep\n          });\n        }\n      } // Joyride was running (it might still be), and the index has been changed\n\n\n      if (isRunning && nextState.index !== index) {\n        this.triggerCallback({\n          action: nextState.action,\n          index: index,\n          type: callbackTypes.STEP_AFTER,\n          step: step\n        }); // Attempted to advance to a step with a target that cannot be found\n\n        /* istanbul ignore else */\n\n        if (nextStep && !hasRenderedTarget) {\n          console.warn('Target not mounted', nextStep, nextState.action); //eslint-disable-line no-console\n\n          this.triggerCallback({\n            action: nextState.action,\n            index: nextState.index,\n            type: callbackTypes.TARGET_NOT_FOUND,\n            step: nextStep\n          });\n        } // There's a next step and the index is > 0\n        // (which means STEP_BEFORE wasn't sent as part of the start handler above)\n        else if (nextStep && nextState.index) {\n            this.triggerCallback({\n              action: nextState.action,\n              index: nextState.index,\n              type: callbackTypes.STEP_BEFORE,\n              step: nextStep\n            });\n          }\n      } // Running, and a tooltip is being turned on/off or the index is changing\n\n\n      if (nextState.isRunning && (shouldRenderTooltip !== nextState.shouldRenderTooltip || nextState.index !== index)) {\n        // Going to show a tooltip\n        if (nextState.shouldRenderTooltip) {\n          this.triggerCallback({\n            action: nextState.action || (nextState.index === 0 ? 'autostart' : ''),\n            index: nextState.index,\n            type: callbackTypes.TOOLTIP_BEFORE,\n            step: nextStep\n          });\n        } // Going to show a beacon\n        else {\n            this.triggerCallback({\n              action: nextState.action,\n              index: nextState.index,\n              type: callbackTypes.BEACON_BEFORE,\n              step: nextStep\n            });\n          }\n      } // Joyride was changed to a step index which doesn't exist (hit the end)\n\n\n      if (!nextState.isRunning && nextSteps.length && index !== nextState.index && !nextStep) {\n        this.triggerCallback({\n          action: nextState.action,\n          type: callbackTypes.FINISHED,\n          steps: nextSteps,\n          isTourSkipped: nextState.isTourSkipped\n        });\n      }\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _state3 = this.state,\n          index = _state3.index,\n          shouldRedraw = _state3.shouldRedraw,\n          isRunning = _state3.isRunning,\n          shouldRun = _state3.shouldRun,\n          standaloneData = _state3.standaloneData;\n      var _props3 = this.props,\n          scrollToFirstStep = _props3.scrollToFirstStep,\n          scrollToSteps = _props3.scrollToSteps,\n          steps = _props3.steps;\n      var step = steps[index];\n      var scrollTop = this.getScrollTop();\n      var shouldScroll = (scrollToFirstStep || index > 0 || prevState.index > index) && step && !step.isFixed; // fixed steps don't need to scroll\n\n      if (shouldRedraw && step) {\n        this.calcPlacement();\n      }\n\n      if (isRunning && scrollToSteps && shouldScroll && scrollTop >= 0) {\n        scroll.top(getRootEl(), this.getScrollTop());\n      }\n\n      if (steps.length && !isRunning && shouldRun && !standaloneData) {\n        this.start();\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var _this3 = this;\n\n      window.removeEventListener('resize', this.listeners.resize);\n      /* istanbul ignore else */\n\n      if (this.listeners.keyboard) {\n        document.body.removeEventListener('keydown', this.listeners.keyboard);\n      }\n      /* istanbul ignore else */\n\n\n      if (Object.keys(this.listeners.tooltips).length) {\n        Object.keys(this.listeners.tooltips).map(function (key) {\n          return {\n            el: document.querySelector(key),\n            event: _this3.listeners.tooltips[key].event,\n            cb: _this3.listeners.tooltips[key].cb,\n            key: key\n          };\n        }).filter(function (_ref) {\n          var el = _ref.el;\n          return !!el;\n        }).forEach(function (_ref2) {\n          var el = _ref2.el,\n              event = _ref2.event,\n              cb = _ref2.cb,\n              key = _ref2.key;\n          el.removeEventListener(event, cb);\n          delete _this3.listeners.tooltips[key];\n        });\n      }\n    }\n    /**\n     * Starts the tour\n     *\n     * @private\n     *\n     * @param {boolean} [autorun] - Starts with the first tooltip opened\n     * @param {Array} [steps] - Array of steps, defaults to this.props.steps\n     * @param {number} [startIndex] - Optional step index to start joyride at\n     */\n\n  }, {\n    key: 'start',\n    value: function start(autorun) {\n      var steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.steps;\n      var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.state.index;\n      var hasMountedTarget = Boolean(this.getStepTargetElement(steps[startIndex]));\n      var shouldRenderTooltip = autorun === true && hasMountedTarget;\n      logger({\n        type: 'joyride:start',\n        msg: ['autorun:', autorun === true],\n        debug: this.props.debug\n      });\n      this.setState({\n        action: 'start',\n        index: startIndex,\n        isRunning: Boolean(steps.length) && hasMountedTarget,\n        shouldRenderTooltip: shouldRenderTooltip,\n        shouldRun: !steps.length\n      });\n    }\n    /**\n     * Stop the tour\n     *\n     * @private\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop() {\n      logger({\n        type: 'joyride:stop',\n        debug: this.props.debug\n      });\n      this.setState({\n        isRunning: false,\n        shouldRenderTooltip: false\n      });\n    }\n    /**\n     * Move to the next step, if there is one.  If there is no next step, hide the tooltip.\n     */\n\n  }, {\n    key: 'next',\n    value: function next() {\n      var _state4 = this.state,\n          index = _state4.index,\n          shouldRenderTooltip = _state4.shouldRenderTooltip;\n      var steps = this.props.steps;\n      var nextIndex = index + 1;\n      var shouldDisplay = Boolean(steps[nextIndex]) && shouldRenderTooltip;\n      logger({\n        type: 'joyride:next',\n        msg: ['new index:', nextIndex],\n        debug: this.props.debug\n      });\n      this.toggleTooltip({\n        show: shouldDisplay,\n        index: nextIndex,\n        action: 'next'\n      });\n    }\n    /**\n     * Move to the previous step, if there is one.  If there is no previous step, hide the tooltip.\n     */\n\n  }, {\n    key: 'back',\n    value: function back() {\n      var _state5 = this.state,\n          index = _state5.index,\n          shouldRenderTooltip = _state5.shouldRenderTooltip;\n      var steps = this.props.steps;\n      var previousIndex = index - 1;\n      var shouldDisplay = Boolean(steps[previousIndex]) && shouldRenderTooltip;\n      logger({\n        type: 'joyride:back',\n        msg: ['new index:', previousIndex],\n        debug: this.props.debug\n      });\n      this.toggleTooltip({\n        show: shouldDisplay,\n        index: previousIndex,\n        action: 'next'\n      });\n    }\n    /**\n     * Reset Tour\n     *\n     * @param {boolean} [restart] - Starts the new tour right away\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset(restart) {\n      var _state6 = this.state,\n          index = _state6.index,\n          isRunning = _state6.isRunning;\n      var shouldRestart = restart === true;\n\n      var newState = _extends({}, defaultState, {\n        isRunning: shouldRestart,\n        shouldRenderTooltip: this.props.autoStart\n      });\n\n      logger({\n        type: 'joyride:reset',\n        msg: ['restart:', shouldRestart],\n        debug: this.props.debug\n      }); // Force a re-render if necessary\n\n      if (shouldRestart && isRunning === shouldRestart && index === 0) {\n        this.forceUpdate();\n      }\n\n      this.setState(newState);\n    }\n    /**\n     * Retrieve the current progress of your tour\n     *\n     * @returns {{index: number, percentageComplete: number, step: (object|null)}}\n     */\n\n  }, {\n    key: 'getProgress',\n    value: function getProgress() {\n      var index = this.state.index;\n      var steps = this.props.steps;\n      logger({\n        type: 'joyride:getProgress',\n        msg: ['steps:', steps],\n        debug: this.props.debug\n      });\n      return {\n        index: index,\n        percentageComplete: parseFloat((index / steps.length * 100).toFixed(2).replace('.00', '')),\n        step: steps[index]\n      };\n    }\n    /**\n     * Add standalone tooltip events\n     *\n     * @param {Object} data - Similar shape to a 'step', but for a single tooltip\n     */\n\n  }, {\n    key: 'addTooltip',\n    value: function addTooltip(data) {\n      if (!this.checkStepValidity(data)) {\n        logger({\n          type: 'joyride:addTooltip:FAIL',\n          msg: ['data:', data],\n          debug: this.props.debug\n        });\n        return;\n      }\n\n      logger({\n        type: 'joyride:addTooltip',\n        msg: ['data:', data],\n        debug: this.props.debug\n      });\n      var key = data.trigger || sanitizeSelector(data.selector);\n      var el = document.querySelector(key);\n\n      if (!el) {\n        return;\n      }\n\n      el.setAttribute('data-tooltip', JSON.stringify(data));\n      var eventType = data.event || 'click';\n      /* istanbul ignore else */\n\n      if (eventType === 'hover') {\n        this.listeners.tooltips[key + 'mouseenter'] = {\n          event: 'mouseenter',\n          cb: this.handleClickStandaloneTrigger\n        };\n        this.listeners.tooltips[key + 'mouseleave'] = {\n          event: 'mouseleave',\n          cb: this.handleClickStandaloneTrigger\n        };\n        el.addEventListener('mouseenter', this.listeners.tooltips[key + 'mouseenter'].cb);\n        el.addEventListener('mouseleave', this.listeners.tooltips[key + 'mouseleave'].cb);\n      }\n\n      this.listeners.tooltips[key + 'click'] = {\n        event: 'click',\n        cb: this.handleClickStandaloneTrigger\n      };\n      el.addEventListener('click', this.listeners.tooltips[key + 'click'].cb);\n    }\n    /**\n     * Parse the incoming steps\n     *\n     * @deprecated\n     *\n     * @param {Array|Object} steps\n     * @returns {Array}\n     */\n\n  }, {\n    key: 'parseSteps',\n    value: function parseSteps(steps) {\n      console.warn('joyride.parseSteps() is deprecated.  It is no longer necessary to parse steps before providing them to Joyride'); //eslint-disable-line no-console\n\n      return steps;\n    }\n    /**\n     * Verify that a step is valid\n     *\n     * @param {Object} step - A step object\n     * @returns {boolean} - True if the step is valid, false otherwise\n     */\n\n  }, {\n    key: 'checkStepValidity',\n    value: function checkStepValidity(step) {\n      var _this4 = this; // Check that the step is the proper type\n\n\n      if (!step || (typeof step === 'undefined' ? 'undefined' : _typeof(step)) !== 'object' || Array.isArray(step)) {\n        logger({\n          type: 'joyride:checkStepValidity',\n          msg: 'Did not provide a step object.',\n          warn: true,\n          debug: this.props.debug\n        });\n        return false;\n      } // Check that all required step fields are present\n\n\n      var requiredFields = ['selector'];\n\n      var hasRequiredField = function hasRequiredField(requiredField) {\n        var hasField = Boolean(step[requiredField]);\n\n        if (!hasField) {\n          logger({\n            type: 'joyride:checkStepValidity',\n            msg: ['Provided a step without the required ' + requiredField + ' property.', 'Step:', step],\n            warn: true,\n            debug: _this4.props.debug\n          });\n        }\n\n        return hasField;\n      };\n\n      return requiredFields.every(hasRequiredField);\n    }\n    /**\n     * Check one or more steps are valid\n     *\n     * @param {Object|Array} steps - A step object or array of step objects\n     * @returns {boolean} - True if one or more stpes, and all steps are valid, false otherwise\n     */\n\n  }, {\n    key: 'checkStepsValidity',\n    value: function checkStepsValidity(steps) {\n      /* istanbul ignore else */\n      if (!Array.isArray(steps) && (typeof steps === 'undefined' ? 'undefined' : _typeof(steps)) === 'object') {\n        return this.checkStepValidity(steps);\n      } else if (steps.length > 0) {\n        return steps.every(this.checkStepValidity);\n      }\n\n      return false;\n    }\n    /**\n     * Find and return the targeted DOM element based on a step's 'selector'.\n     *\n     * @private\n     * @param {Object} step - A step object\n     * @returns {Element} - A DOM element (if found)\n     */\n\n  }, {\n    key: 'getStepTargetElement',\n    value: function getStepTargetElement(step) {\n      var isValidStep = this.checkStepValidity(step);\n\n      if (!isValidStep) {\n        return null;\n      }\n\n      var el = document.querySelector(sanitizeSelector(step.selector));\n\n      if (!el) {\n        logger({\n          type: 'joyride:getStepTargetElement',\n          msg: 'Target not rendered. For best results only add steps after they are mounted.',\n          warn: true,\n          debug: this.props.debug\n        });\n        return null;\n      }\n\n      return el;\n    }\n    /**\n     * Get an element actual dimensions with margin\n     *\n     * @private\n     * @returns {{height: number, width: number}}\n     */\n\n  }, {\n    key: 'getElementDimensions',\n    value: function getElementDimensions() {\n      var _state7 = this.state,\n          shouldRenderTooltip = _state7.shouldRenderTooltip,\n          standaloneData = _state7.standaloneData;\n      var displayTooltip = standaloneData ? true : shouldRenderTooltip;\n      var el = document.querySelector(displayTooltip ? '.joyride-tooltip' : '.joyride-beacon');\n      var height = 0;\n      var width = 0;\n\n      if (el) {\n        var styles = window.getComputedStyle(el);\n        height = el.clientHeight + parseInt(styles.marginTop || 0, 10) + parseInt(styles.marginBottom || 0, 10);\n        width = el.clientWidth + parseInt(styles.marginLeft || 0, 10) + parseInt(styles.marginRight || 0, 10);\n      }\n\n      return {\n        height: height,\n        width: width\n      };\n    }\n    /**\n     * Get the scrollTop position\n     *\n     * @private\n     * @returns {number}\n     */\n\n  }, {\n    key: 'getScrollTop',\n    value: function getScrollTop() {\n      var _state8 = this.state,\n          index = _state8.index,\n          yPos = _state8.yPos;\n      var _props4 = this.props,\n          offsetParentSelector = _props4.offsetParentSelector,\n          scrollOffset = _props4.scrollOffset,\n          steps = _props4.steps;\n      var step = steps[index];\n      var target = this.getStepTargetElement(step);\n      var offsetParent = document.querySelector(sanitizeSelector(offsetParentSelector));\n\n      if (!target) {\n        return 0;\n      }\n\n      var rect = getOffsetBoundingClientRect(target, offsetParent);\n      var targetTop = rect.top + (window.pageYOffset || document.documentElement.scrollTop);\n      var position = this.calcPosition(step);\n      var scrollTo = 0;\n      /* istanbul ignore else */\n\n      if (/^top/.test(position)) {\n        scrollTo = Math.floor(yPos - scrollOffset);\n      } else if (/^bottom|^left|^right/.test(position)) {\n        scrollTo = Math.floor(targetTop - scrollOffset);\n      }\n\n      return scrollTo;\n    }\n    /**\n     * Trigger the callback.\n     *\n     * @private\n     * @param {Object} options\n     */\n\n  }, {\n    key: 'triggerCallback',\n    value: function triggerCallback(options) {\n      var callback = this.props.callback;\n      /* istanbul ignore else */\n\n      if (typeof callback === 'function') {\n        logger({\n          type: 'joyride:triggerCallback',\n          msg: [options],\n          debug: this.props.debug\n        });\n        callback(options);\n      }\n    }\n    /**\n     * Keydown event listener\n     *\n     * @private\n     * @param {Event} e - Keyboard event\n     */\n\n    /**\n     * Tooltip event listener\n     *\n     * @private\n     * @param {Event} e - Click event\n     */\n\n    /**\n     * Beacon click event listener\n     *\n     * @private\n     * @param {Event} e - Click event\n     */\n\n    /**\n     * Tooltip click event listener\n     *\n     * @private\n     * @param {Event} e - Click event\n     */\n\n  }, {\n    key: 'toggleTooltip',\n\n    /**\n     * Toggle Tooltip's visibility\n     *\n     * @private\n     * @param {Object} options - Immediately destructured argument object\n     * @param {Boolean} options.show - Render the tooltip or the beacon\n     * @param {Number} options.index - The tour's new index\n     * @param {string} [options.action] - The action being undertaken.\n     * @param {Array} [options.steps] - The array of step objects that is going to be rendered\n     */\n    value: function toggleTooltip(_ref3) {\n      var show = _ref3.show,\n          _ref3$index = _ref3.index,\n          index = _ref3$index === undefined ? this.state.index : _ref3$index,\n          action = _ref3.action,\n          _ref3$steps = _ref3.steps,\n          steps = _ref3$steps === undefined ? this.props.steps : _ref3$steps;\n      var nextStep = steps[index];\n      var hasMountedTarget = Boolean(this.getStepTargetElement(nextStep));\n      this.setState({\n        action: action,\n        index: index,\n        // Stop playing if there is no next step or can't find the target\n        isRunning: nextStep && hasMountedTarget ? this.state.isRunning : false,\n        // If we are not showing now, or there is no target, we'll need to redraw eventually\n        shouldRedraw: !show || !hasMountedTarget,\n        shouldRenderTooltip: show && hasMountedTarget,\n        xPos: -1000,\n        yPos: -1000\n      });\n    }\n    /**\n     * Position absolute elements next to its target\n     *\n     * @private\n     */\n\n  }, {\n    key: 'calcPlacement',\n    value: function calcPlacement() {\n      var _state9 = this.state,\n          index = _state9.index,\n          isRunning = _state9.isRunning,\n          standaloneData = _state9.standaloneData,\n          shouldRenderTooltip = _state9.shouldRenderTooltip;\n      var _props5 = this.props,\n          offsetParentSelector = _props5.offsetParentSelector,\n          steps = _props5.steps,\n          tooltipOffset = _props5.tooltipOffset;\n      var step = standaloneData || steps[index] || {};\n      var displayTooltip = standaloneData ? true : shouldRenderTooltip;\n      var target = this.getStepTargetElement(step);\n      var offsetParent = document.querySelector(sanitizeSelector(offsetParentSelector));\n      logger({\n        type: 'joyride:calcPlacement' + this.getRenderStage(),\n        msg: ['step:', step],\n        debug: this.props.debug\n      });\n      /* istanbul ignore else */\n\n      if (!target) {\n        return;\n      }\n\n      var placement = {\n        x: -1000,\n        y: -1000\n      };\n      /* istanbul ignore else */\n\n      if (step && (standaloneData || isRunning && steps[index])) {\n        var offsetX = nested.get(step, 'style.beacon.offsetX') || 0;\n        var offsetY = nested.get(step, 'style.beacon.offsetY') || 0;\n        var position = this.calcPosition(step);\n        var scrollingElement = getRootEl().getBoundingClientRect();\n        var scrollTop = step.isFixed === true ? 0 : scrollingElement.top;\n        var component = this.getElementDimensions();\n        var rect = getOffsetBoundingClientRect(target, offsetParent); // Calculate x position\n\n        if (/^left/.test(position)) {\n          placement.x = rect.left - (displayTooltip ? component.width + tooltipOffset : component.width / 2 + offsetX);\n        } else if (/^right/.test(position)) {\n          placement.x = rect.left + rect.width - (displayTooltip ? -tooltipOffset : component.width / 2 - offsetX);\n        } else {\n          placement.x = rect.left + (rect.width / 2 - component.width / 2);\n        } // Calculate y position\n\n\n        if (/^top/.test(position)) {\n          placement.y = rect.top - scrollTop - (displayTooltip ? component.height + tooltipOffset : component.height / 2 + offsetY);\n        } else if (/^bottom/.test(position)) {\n          placement.y = rect.top - scrollTop + (rect.height - (displayTooltip ? -tooltipOffset : component.height / 2 - offsetY));\n        } else {\n          placement.y = rect.top - scrollTop;\n        }\n        /* istanbul ignore else */\n\n\n        if (/^bottom|^top/.test(position)) {\n          if (/left/.test(position)) {\n            placement.x = rect.left - (displayTooltip ? tooltipOffset : component.width / 2);\n          } else if (/right/.test(position)) {\n            placement.x = rect.left + (rect.width - (displayTooltip ? component.width - tooltipOffset : component.width / 2));\n          }\n        }\n\n        this.setState({\n          shouldRedraw: false,\n          xPos: this.preventWindowOverflow(Math.ceil(placement.x), 'x', component.width, component.height),\n          yPos: this.preventWindowOverflow(Math.ceil(placement.y), 'y', component.width, component.height)\n        });\n      }\n    }\n    /**\n     * Update position for overflowing elements.\n     *\n     * @private\n     * @param {Object} step\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'calcPosition',\n    value: function calcPosition(step) {\n      var _props6 = this.props,\n          offsetParentSelector = _props6.offsetParentSelector,\n          tooltipOffset = _props6.tooltipOffset;\n      var scrollingElement = getRootEl();\n      var scrollingElementRect = scrollingElement.getBoundingClientRect();\n      var target = this.getStepTargetElement(step);\n      var offsetParent = document.querySelector(sanitizeSelector(offsetParentSelector));\n      var rect = getOffsetBoundingClientRect(target, offsetParent);\n\n      var _getElementDimensions = this.getElementDimensions(),\n          height = _getElementDimensions.height,\n          _getElementDimensions2 = _getElementDimensions.width,\n          width = _getElementDimensions2 === undefined ? DEFAULTS.minWidth : _getElementDimensions2;\n\n      var position = step.position || DEFAULTS.position;\n\n      if (/^left/.test(position) && rect.left - (width + tooltipOffset) < 0) {\n        position = 'top';\n      } else if (/^right/.test(position) && rect.left + rect.width + (width + tooltipOffset) > scrollingElementRect.width) {\n        position = 'bottom';\n      }\n\n      if (/^top/.test(position) && (rect.top + scrollingElement.scrollTop - (height + tooltipOffset) < 0 || step.isFixed && rect.top - height < 0)) {\n        position = 'bottom';\n      } else if (/^bottom/.test(position) && (rect.top + scrollingElement.scrollTop + (height + tooltipOffset) > getDocHeight() || step.isFixed && rect.top + rect.height + height > scrollingElementRect.height)) {\n        position = 'top';\n      }\n\n      return position;\n    }\n    /**\n     * Get the render stage.\n     *\n     * @private\n     * @returns {string}\n     */\n\n  }, {\n    key: 'getRenderStage',\n    value: function getRenderStage() {\n      var _state10 = this.state,\n          shouldRedraw = _state10.shouldRedraw,\n          xPos = _state10.xPos;\n\n      if (shouldRedraw) {\n        return ':redraw';\n      } else if (xPos < 0) {\n        return ':pre-render';\n      }\n\n      return '';\n    }\n    /**\n     * Prevent tooltip to render outside the window\n     *\n     * @private\n     * @param {Number} value - The axis position\n     * @param {String} axis - The Axis X or Y\n     * @param {Number} elWidth - The target element width\n     * @param {Number} elHeight - The target element height\n     * @returns {Number}\n     */\n\n  }, {\n    key: 'preventWindowOverflow',\n    value: function preventWindowOverflow(value, axis, elWidth, elHeight) {\n      var winWidth = window.innerWidth;\n      var docHeight = getDocHeight();\n      var newValue = value;\n      /* istanbul ignore else */\n\n      if (axis === 'x') {\n        if (value + elWidth >= winWidth) {\n          newValue = winWidth - elWidth - 15;\n        } else if (value < 15) {\n          newValue = 15;\n        }\n      } else if (axis === 'y') {\n        if (value + elHeight >= docHeight) {\n          newValue = docHeight - elHeight - 15;\n        } else if (value < 15) {\n          newValue = 15;\n        }\n      }\n\n      return newValue;\n    }\n    /**\n     * Create a React Element\n     *\n     * @private\n     * @returns {boolean|ReactComponent}\n     */\n\n  }, {\n    key: 'createComponent',\n    value: function createComponent() {\n      var _state11 = this.state,\n          index = _state11.index,\n          shouldRedraw = _state11.shouldRedraw,\n          shouldRenderTooltip = _state11.shouldRenderTooltip,\n          standaloneData = _state11.standaloneData,\n          xPos = _state11.xPos,\n          yPos = _state11.yPos;\n      var _props7 = this.props,\n          disableOverlay = _props7.disableOverlay,\n          holePadding = _props7.holePadding,\n          locale = _props7.locale,\n          offsetParentSelector = _props7.offsetParentSelector,\n          showBackButton = _props7.showBackButton,\n          showOverlay = _props7.showOverlay,\n          showSkipButton = _props7.showSkipButton,\n          showStepsProgress = _props7.showStepsProgress,\n          steps = _props7.steps,\n          type = _props7.type;\n      var currentStep = standaloneData || steps[index];\n\n      var step = _extends({}, currentStep);\n\n      var target = this.getStepTargetElement(step);\n      var component = void 0;\n      var allowClicksThruHole = step && step.allowClicksThruHole || this.props.allowClicksThruHole;\n      var shouldShowOverlay = standaloneData ? false : showOverlay;\n      var buttons = {\n        primary: locale.close\n      };\n      logger({\n        type: 'joyride:createComponent' + this.getRenderStage(),\n        msg: ['component:', shouldRenderTooltip || standaloneData ? 'Tooltip' : 'Beacon', 'animate:', xPos > -1 && !shouldRedraw, 'step:', step],\n        debug: this.props.debug,\n        warn: !target\n      });\n\n      if (!target) {\n        return false;\n      }\n\n      if (shouldRenderTooltip || standaloneData) {\n        var position = this.calcPosition(step);\n        /* istanbul ignore else */\n\n        if (!standaloneData) {\n          /* istanbul ignore else */\n          if (['continuous', 'guided'].indexOf(type) !== -1) {\n            buttons.primary = locale.last;\n            /* istanbul ignore else */\n\n            if (steps[index + 1]) {\n              if (showStepsProgress) {\n                var next = locale.next;\n\n                if (typeof locale.next === 'string') {\n                  next = React.createElement('span', null, locale.next);\n                }\n\n                buttons.primary = React.createElement('span', null, next, ' ', React.createElement('span', null, index + 1 + '/' + steps.length));\n              } else {\n                buttons.primary = locale.next;\n              }\n            }\n\n            if (showBackButton && index > 0) {\n              buttons.secondary = locale.back;\n            }\n          }\n\n          if (showSkipButton) {\n            buttons.skip = locale.skip;\n          }\n        }\n\n        component = React.createElement(Tooltip, {\n          allowClicksThruHole: allowClicksThruHole,\n          animate: xPos > -1 && !shouldRedraw,\n          buttons: buttons,\n          disableOverlay: disableOverlay,\n          holePadding: holePadding,\n          offsetParentSelector: offsetParentSelector,\n          position: position,\n          selector: sanitizeSelector(step.selector),\n          showOverlay: shouldShowOverlay,\n          step: step,\n          standalone: Boolean(standaloneData),\n          target: target,\n          type: type,\n          xPos: xPos,\n          yPos: yPos,\n          onClick: this.handleClickTooltip,\n          onRender: this.handleRenderTooltip\n        });\n      } else {\n        component = React.createElement(Beacon, {\n          step: step,\n          xPos: xPos,\n          yPos: yPos,\n          onTrigger: this.handleClickBeacon,\n          eventType: step.type || 'click'\n        });\n      }\n\n      return component;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _state12 = this.state,\n          index = _state12.index,\n          isRunning = _state12.isRunning,\n          standaloneData = _state12.standaloneData;\n      var steps = this.props.steps;\n      var hasStep = Boolean(steps[index]);\n      var component = void 0;\n      var standaloneComponent = void 0;\n\n      if (isRunning && hasStep) {\n        logger({\n          type: 'joyride:render' + this.getRenderStage(),\n          msg: ['step:', steps[index]],\n          debug: this.props.debug\n        });\n      } else if (!isRunning && standaloneData) {\n        logger({\n          type: 'joyride:render',\n          msg: ['tooltip:', standaloneData],\n          debug: this.props.debug\n        });\n      }\n\n      if (standaloneData) {\n        standaloneComponent = this.createComponent();\n      } else if (isRunning && hasStep) {\n        component = this.createComponent();\n      }\n\n      return React.createElement('div', {\n        className: 'joyride'\n      }, component, standaloneComponent);\n    }\n  }]);\n\n  return Joyride;\n}(React.Component);\n\nJoyride.propTypes = {\n  allowClicksThruHole: PropTypes.bool,\n  autoStart: PropTypes.bool,\n  callback: PropTypes.func,\n  debug: PropTypes.bool,\n  disableOverlay: PropTypes.bool,\n  holePadding: PropTypes.number,\n  keyboardNavigation: PropTypes.bool,\n  locale: PropTypes.object,\n  offsetParentSelector: PropTypes.string,\n  resizeDebounce: PropTypes.bool,\n  resizeDebounceDelay: PropTypes.number,\n  run: PropTypes.bool,\n  scrollOffset: PropTypes.number,\n  scrollToFirstStep: PropTypes.bool,\n  scrollToSteps: PropTypes.bool,\n  showBackButton: PropTypes.bool,\n  showOverlay: PropTypes.bool,\n  showSkipButton: PropTypes.bool,\n  showStepsProgress: PropTypes.bool,\n  stepIndex: PropTypes.number,\n  steps: PropTypes.array,\n  tooltipOffset: PropTypes.number,\n  type: PropTypes.string\n};\nJoyride.defaultProps = {\n  allowClicksThruHole: false,\n  autoStart: false,\n  debug: false,\n  disableOverlay: false,\n  holePadding: 5,\n  keyboardNavigation: true,\n  locale: {\n    back: 'Back',\n    close: 'Close',\n    last: 'Last',\n    next: 'Next',\n    skip: 'Skip'\n  },\n  offsetParentSelector: 'body',\n  resizeDebounce: false,\n  resizeDebounceDelay: 200,\n  run: false,\n  scrollOffset: 20,\n  scrollToFirstStep: false,\n  scrollToSteps: true,\n  showBackButton: true,\n  showOverlay: true,\n  showSkipButton: false,\n  showStepsProgress: false,\n  stepIndex: 0,\n  steps: [],\n  tooltipOffset: 15,\n  type: 'single'\n};\nexport default Joyride;","map":null,"metadata":{},"sourceType":"module"}