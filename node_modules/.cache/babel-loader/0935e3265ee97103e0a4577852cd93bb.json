{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { browser, getOffsetBoundingClientRect, sanitizeSelector } from './utils';\n\nvar JoyrideTooltip = function (_React$Component) {\n  _inherits(JoyrideTooltip, _React$Component);\n\n  function JoyrideTooltip(props) {\n    _classCallCheck(this, JoyrideTooltip);\n\n    var _this = _possibleConstructorReturn(this, (JoyrideTooltip.__proto__ || Object.getPrototypeOf(JoyrideTooltip)).call(this, props));\n\n    _this.handleMouseMove = function (e) {\n      var event = e || window.e;\n      var hole = _this.state.styles.hole;\n      var offsetY = hole.position === 'fixed' ? event.clientY : event.pageY;\n      var offsetX = hole.position === 'fixed' ? event.clientX : event.pageX;\n      var inHoleHeight = offsetY >= hole.top && offsetY <= hole.top + hole.height;\n      var inHoleWidth = offsetX >= hole.left && offsetX <= hole.left + hole.width;\n      var inHole = inHoleWidth && inHoleHeight;\n\n      if (inHole && !_this.state.mouseOverHole) {\n        _this.setState({\n          mouseOverHole: true\n        });\n      }\n\n      if (!inHole && _this.state.mouseOverHole) {\n        _this.setState({\n          mouseOverHole: false\n        });\n      }\n    };\n\n    _this.state = {};\n    return _this;\n  }\n\n  _createClass(JoyrideTooltip, [{\n    key: 'componentWillMount',\n    value: function componentWillMount() {\n      var opts = this.setOpts();\n      var styles = this.setStyles(this.props.step.style, opts, this.props);\n      this.setState({\n        styles: styles,\n        opts: opts\n      });\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _props = this.props,\n          allowClicksThruHole = _props.allowClicksThruHole,\n          onRender = _props.onRender,\n          showOverlay = _props.showOverlay;\n      this.forceUpdate();\n      onRender();\n\n      if (showOverlay && allowClicksThruHole) {\n        document.addEventListener('mousemove', this.handleMouseMove, false);\n      }\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      var nextAllowClicksThruHole = nextProps.allowClicksThruHole,\n          nextAnimate = nextProps.animate,\n          nextStandalone = nextProps.standalone,\n          nextStep = nextProps.step,\n          nextHolePadding = nextProps.holePadding,\n          nextPosition = nextProps.position,\n          nextXPos = nextProps.xPos,\n          nextYPos = nextProps.yPos,\n          nextShowOverlay = nextProps.showOverlay;\n      var _props2 = this.props,\n          allowClicksThruHole = _props2.allowClicksThruHole,\n          animate = _props2.animate,\n          standalone = _props2.standalone,\n          step = _props2.step,\n          holePadding = _props2.holePadding,\n          position = _props2.position,\n          xPos = _props2.xPos,\n          yPos = _props2.yPos,\n          showOverlay = _props2.showOverlay;\n      /* istanbul ignore else */\n\n      if (nextAnimate !== animate || nextStandalone !== standalone || nextStep !== step || nextHolePadding !== holePadding || nextPosition !== position || nextXPos !== xPos || nextYPos !== yPos) {\n        var opts = this.setOpts(nextProps);\n        var styles = this.setStyles(nextProps.step.style, opts, nextProps);\n        this.setState({\n          styles: styles,\n          opts: opts\n        });\n      } // If showOverlay changed, we might need to allow clicks in the overlay hole\n\n\n      if (nextShowOverlay !== showOverlay) {\n        if (nextShowOverlay && nextAllowClicksThruHole) {\n          document.addEventListener('mousemove', this.handleMouseMove, false);\n        } else {\n          document.removeEventListener('mousemove', this.handleMouseMove, false);\n        }\n      } // If allowClickInHole changed, we need to enable or disable clicking in the overlay hole\n\n\n      if (nextAllowClicksThruHole !== allowClicksThruHole) {\n        if (nextAllowClicksThruHole) {\n          document.addEventListener('mousemove', this.handleMouseMove, false);\n        } else {\n          document.removeEventListener('mousemove', this.handleMouseMove, false);\n        }\n      }\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps) {\n      var _props3 = this.props,\n          onRender = _props3.onRender,\n          selector = _props3.selector;\n\n      if (prevProps.selector !== selector) {\n        this.forceUpdate();\n        onRender();\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      document.removeEventListener('mousemove', this.handleMouseMove, false);\n    }\n  }, {\n    key: 'getArrowPosition',\n    value: function getArrowPosition(position) {\n      var arrowPosition = position;\n\n      if (window.innerWidth < 480) {\n        if (position < 8) {\n          arrowPosition = 8;\n        } else if (position > 92) {\n          arrowPosition = 92;\n        }\n      } else if (window.innerWidth < 1024) {\n        if (position < 6) {\n          arrowPosition = 6;\n        } else if (position > 94) {\n          arrowPosition = 94;\n        }\n      } else if (position < 5) {\n        arrowPosition = 5;\n      } else if (position > 95) {\n        arrowPosition = 95;\n      }\n\n      return arrowPosition;\n    }\n  }, {\n    key: 'generateArrow',\n    value: function generateArrow() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      opts.location = opts.location || 'top';\n      opts.color = opts.color || '#f04';\n      opts.color = opts.color.replace('#', '%23');\n      opts.width = opts.width || 36;\n      opts.height = opts.width / 2;\n      opts.scale = opts.width / 16;\n      opts.rotate = '0';\n      var height = opts.height,\n          rotate = opts.rotate,\n          width = opts.width;\n\n      if (opts.location === 'bottom') {\n        rotate = '180 8 4';\n      } else if (opts.location === 'left') {\n        height = opts.width;\n        width = opts.height;\n        rotate = '270 8 8';\n      } else if (opts.location === 'right') {\n        height = opts.width;\n        width = opts.height;\n        rotate = '90 4 4';\n      }\n\n      return 'data:image/svg+xml,%3Csvg%20width%3D%22' + width + '%22%20height%3D%22' + height + '%22%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpolygon%20points%3D%220%2C%200%208%2C%208%2016%2C0%22%20fill%3D%22' + opts.color + '%22%20transform%3D%22scale%28' + opts.scale + '%29%20rotate%28' + rotate + '%29%22%3E%3C%2Fpolygon%3E%3C%2Fsvg%3E';\n    }\n    /**\n     * Calculate styles based on those passed in with the step, or calculated opts, or props\n     *\n     * @param {Object} stepStyles              Style object provided with step\n     * @param {Object} opts                    Options object calculated from this.setOpts\n     * @param {string} opts.arrowPosition      Used for left/right positioing of arrow when on bottom or top\n     * @param {Object} opts.rect               BoundingClientRect of target element\n     * @param {string} opts.positonBaseClass   Base position of tooltip (top, bottom, left, right)\n     * @param {Object} props                   Positioning properties: cssPosition, xPos, and yPos\n     * @returns {Object}                       Calculated styles for arrow, buttons, header, main, footer, hole, and tooltip\n     */\n\n  }, {\n    key: 'setStyles',\n    value: function setStyles(stepStyles, opts, props) {\n      var holePadding = props.holePadding,\n          step = props.step,\n          xPos = props.xPos,\n          yPos = props.yPos;\n      var isFixed = step.isFixed === true;\n      var styles = {\n        arrow: {\n          left: opts.arrowPosition\n        },\n        buttons: {},\n        header: {},\n        main: {},\n        footer: {},\n        hole: {},\n        tooltip: {\n          position: isFixed ? 'fixed' : 'absolute',\n          top: Math.round(yPos),\n          left: Math.round(xPos)\n        }\n      };\n      styles.hole = {\n        top: Math.round(opts.rect.top - (isFixed ? 0 : document.body.getBoundingClientRect().top) - holePadding),\n        left: Math.round(opts.rect.left - holePadding),\n        width: Math.round(opts.rect.width + holePadding * 2),\n        height: Math.round(opts.rect.height + holePadding * 2)\n      };\n\n      if (isFixed) {\n        styles.hole.position = 'fixed';\n      }\n\n      styles.buttons = {\n        back: {},\n        close: {},\n        primary: {},\n        skip: {}\n      };\n      /* Styling */\n\n      /* istanbul ignore else */\n\n      if (stepStyles) {\n        if (stepStyles.backgroundColor) {\n          styles.arrow.backgroundImage = 'url(\"' + this.generateArrow({\n            location: opts.positonBaseClass,\n            color: stepStyles.backgroundColor\n          }) + '\")';\n          styles.tooltip.backgroundColor = stepStyles.backgroundColor;\n        }\n\n        if (stepStyles.borderRadius) {\n          styles.tooltip.borderRadius = stepStyles.borderRadius;\n        }\n\n        if (stepStyles.color) {\n          styles.buttons.primary.color = stepStyles.color;\n          styles.buttons.close.color = stepStyles.color;\n          styles.buttons.skip.color = stepStyles.color;\n          styles.header.color = stepStyles.color;\n          styles.tooltip.color = stepStyles.color;\n\n          if (stepStyles.mainColor && stepStyles.mainColor === stepStyles.color) {\n            styles.buttons.primary.color = stepStyles.backgroundColor;\n          }\n        }\n\n        if (stepStyles.mainColor) {\n          styles.buttons.primary.backgroundColor = stepStyles.mainColor;\n          styles.buttons.back.color = stepStyles.mainColor;\n          styles.header.borderColor = stepStyles.mainColor;\n        }\n\n        if (stepStyles.textAlign) {\n          styles.tooltip.textAlign = stepStyles.textAlign;\n        }\n\n        if (stepStyles.width) {\n          styles.tooltip.width = stepStyles.width;\n        }\n\n        if (stepStyles.header) {\n          styles.header = _extends({}, styles.header, stepStyles.header);\n        }\n\n        if (stepStyles.main) {\n          styles.main = _extends({}, styles.main, stepStyles.main);\n        }\n\n        if (stepStyles.footer) {\n          styles.footer = _extends({}, styles.footer, stepStyles.footer);\n        }\n\n        if (stepStyles.back) {\n          styles.buttons.back = _extends({}, styles.buttons.back, stepStyles.back);\n        }\n\n        if (stepStyles.arrow) {\n          styles.arrow = _extends({}, styles.arrow, stepStyles.arrow);\n        }\n\n        if (stepStyles.button) {\n          styles.buttons.primary = _extends({}, styles.buttons.primary, stepStyles.button);\n        }\n\n        if (stepStyles.close) {\n          styles.buttons.close = _extends({}, styles.buttons.close, stepStyles.close);\n        }\n\n        if (stepStyles.skip) {\n          styles.buttons.skip = _extends({}, styles.buttons.skip, stepStyles.skip);\n        }\n\n        if (stepStyles.hole) {\n          styles.hole = _extends({}, stepStyles.hole, styles.hole);\n        }\n      }\n\n      return styles;\n    }\n  }, {\n    key: 'setOpts',\n    value: function setOpts() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var animate = props.animate,\n          offsetParentSelector = props.offsetParentSelector,\n          position = props.position,\n          standalone = props.standalone,\n          target = props.target,\n          xPos = props.xPos;\n      var offsetParent = document.querySelector(sanitizeSelector(offsetParentSelector));\n      var tooltip = document.querySelector('.joyride-tooltip');\n      var opts = {\n        classes: ['joyride-tooltip'],\n        rect: getOffsetBoundingClientRect(target, offsetParent),\n        positionClass: position\n      };\n      opts.positonBaseClass = opts.positionClass.match(/-/) ? opts.positionClass.split('-')[0] : opts.positionClass;\n\n      if ((/^bottom$/.test(opts.positionClass) || /^top$/.test(opts.positionClass)) && xPos > -1) {\n        opts.tooltip = {\n          width: 450\n        };\n        /* istanbul ignore else */\n\n        if (tooltip) {\n          opts.tooltip = getOffsetBoundingClientRect(tooltip, offsetParent);\n        }\n\n        opts.targetMiddle = opts.rect.left + opts.rect.width / 2;\n        opts.arrowPosition = ((opts.targetMiddle - xPos) / opts.tooltip.width * 100).toFixed(2);\n        opts.arrowPosition = this.getArrowPosition(opts.arrowPosition) + '%';\n      }\n\n      if (standalone) {\n        opts.classes.push('joyride-tooltip--standalone');\n      }\n\n      if (opts.positonBaseClass !== opts.positionClass) {\n        opts.classes.push(opts.positonBaseClass);\n      }\n\n      opts.classes.push(opts.positionClass);\n\n      if (animate) {\n        opts.classes.push('joyride-tooltip--animate');\n      }\n\n      return opts;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props4 = this.props,\n          buttons = _props4.buttons,\n          disableOverlay = _props4.disableOverlay,\n          onClick = _props4.onClick,\n          selector = _props4.selector,\n          showOverlay = _props4.showOverlay,\n          step = _props4.step,\n          target = _props4.target,\n          type = _props4.type;\n\n      if (!target) {\n        return undefined;\n      }\n\n      var _state = this.state,\n          opts = _state.opts,\n          styles = _state.styles;\n      var output = {};\n\n      if (step.title) {\n        output.header = React.createElement('div', {\n          className: 'joyride-tooltip__header',\n          style: styles.header\n        }, step.title);\n      }\n\n      if (buttons.skip) {\n        output.skip = React.createElement('button', {\n          className: 'joyride-tooltip__button joyride-tooltip__button--skip',\n          style: styles.buttons.skip,\n          'data-type': 'skip',\n          onClick: onClick\n        }, buttons.skip);\n      } // Why is this here?\n\n\n      if (!step.text || typeof step.text === 'string') {\n        output.main = React.createElement('div', {\n          className: 'joyride-tooltip__main',\n          style: styles.main,\n          dangerouslySetInnerHTML: {\n            __html: step.text || ''\n          }\n        });\n      } else {\n        output.main = React.createElement('div', {\n          className: 'joyride-tooltip__main',\n          style: styles.main\n        }, step.text);\n      }\n\n      if (buttons.secondary) {\n        output.secondary = React.createElement('button', {\n          className: 'joyride-tooltip__button joyride-tooltip__button--secondary',\n          style: styles.buttons.back,\n          'data-type': 'back',\n          onClick: onClick\n        }, buttons.secondary);\n      }\n\n      if (step.event === 'hover') {\n        styles.buttons.close.opacity = 0;\n      }\n\n      output.tooltipComponent = React.createElement('div', {\n        className: opts.classes.join(' '),\n        style: styles.tooltip,\n        'data-target': selector\n      }, React.createElement('div', {\n        className: 'joyride-tooltip__triangle joyride-tooltip__triangle-' + opts.positionClass,\n        style: styles.arrow\n      }), React.createElement('button', {\n        className: 'joyride-tooltip__close' + (output.header ? ' joyride-tooltip__close--header' : ''),\n        style: styles.buttons.close,\n        'data-type': 'close',\n        onClick: onClick\n      }), output.header, output.main, React.createElement('div', {\n        className: 'joyride-tooltip__footer',\n        style: styles.footer\n      }, output.skip, output.secondary, React.createElement('button', {\n        className: 'joyride-tooltip__button joyride-tooltip__button--primary',\n        style: styles.buttons.primary,\n        'data-type': ['single', 'casual'].indexOf(type) !== -1 ? 'close' : 'next',\n        onClick: onClick\n      }, buttons.primary)));\n\n      if (showOverlay) {\n        // Empty onClick handler is for iOS touch devices (https://github.com/gilbarbara/react-joyride/issues/204)\n        output.hole = React.createElement('div', {\n          className: 'joyride-hole ' + browser,\n          style: styles.hole,\n          onClick: function onClick() {}\n        });\n      }\n\n      if (!showOverlay) {\n        return output.tooltipComponent;\n      }\n\n      var overlayStyles = {\n        cursor: disableOverlay ? 'default' : 'pointer',\n        height: document.body.clientHeight,\n        pointerEvents: this.state.mouseOverHole ? 'none' : 'auto'\n      };\n      return React.createElement('div', {\n        className: 'joyride-overlay',\n        style: overlayStyles,\n        'data-type': 'close',\n        onClick: !disableOverlay ? onClick : undefined\n      }, output.hole, output.tooltipComponent);\n    }\n  }]);\n\n  return JoyrideTooltip;\n}(React.Component);\n\nJoyrideTooltip.propTypes = {\n  allowClicksThruHole: PropTypes.bool.isRequired,\n  animate: PropTypes.bool.isRequired,\n  buttons: PropTypes.object.isRequired,\n  disableOverlay: PropTypes.bool,\n  holePadding: PropTypes.number,\n  offsetParentSelector: PropTypes.string,\n  //eslint-disable-line react/no-unused-prop-types\n  onClick: PropTypes.func.isRequired,\n  onRender: PropTypes.func.isRequired,\n  // position of tooltip with respect to target\n  position: PropTypes.oneOf(['top', 'top-left', 'top-right', 'bottom', 'bottom-left', 'bottom-right', 'right', 'left']).isRequired,\n  // sanitized selector string\n  selector: PropTypes.string.isRequired,\n  showOverlay: PropTypes.bool.isRequired,\n  standalone: PropTypes.bool,\n  step: PropTypes.object.isRequired,\n  // DOM element to target\n  target: PropTypes.object.isRequired,\n  type: PropTypes.string.isRequired,\n  xPos: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n  yPos: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired\n};\nJoyrideTooltip.defaultProps = {\n  buttons: {\n    primary: 'Close'\n  },\n  step: {},\n  xPos: -1000,\n  yPos: -1000\n};\nexport default JoyrideTooltip;","map":null,"metadata":{},"sourceType":"module"}